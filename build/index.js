!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("superwstest",[],t):"object"==typeof exports?exports.superwstest=t():e.superwstest=t()}(global,(function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=4)}([function(e,t){e.exports=require("ws")},function(e,t){e.exports=require("util")},function(e,t){e.exports=require("supertest")},function(e,t){e.exports=require("https")},function(e,t,n){e.exports=n(5)},function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return O}));var r=n(1),o=n(2),s=n(0),c=n(3);class i{constructor(){this.pendingPush=[],this.pendingPop=[]}push(e){if(this.pendingPop.length){const t=this.pendingPop.shift();clearTimeout(t.tm),t.resolve(e)}else this.pendingPush.push(e)}pop(e){return this.pendingPush.length?Promise.resolve(this.pendingPush.shift()):new Promise((t,n)=>{const r={resolve:t,tm:null};this.pendingPop.push(r),void 0!==e&&(r.tm=setTimeout(()=>{!function(e,t){const n=e.indexOf(t);-1!==n&&e.splice(n,1)}(this.pendingPop,r),n(new Error(`Timeout after ${e}ms`))},e))})}}function a(e){return new Uint8Array(e)}function u({data:e,isBinary:t}){if(t)throw new Error("Expected text message, got binary");return String(e)}function f(e){return JSON.parse(u(e))}function d({data:e,isBinary:t}){if(!t)throw new Error("Expected binary message, got text");return a(e)}function p(e,t,n){return new Promise((r,o)=>{e.send(t,n,e=>{e?o(e):r()})}).catch(async t=>{if(t.message&&t.message.includes("WebSocket is not open")){const{code:t,data:n}=await e.closed;throw new Error(`Cannot send message; connection closed with ${t} "${n}"`)}})}function l(e){return"function"==typeof e?e.expectedMessage||"matching function":e instanceof Uint8Array?function(e){return`[${Buffer.from(e.buffer,e.byteOffset,e.byteLength).toString("hex").replace(/(..)(?!$)/g,"$1 ")}]`}(e):JSON.stringify(e)}const h={send:(e,t,n)=>p(e,t,n),sendText:(e,t)=>p(e,String(t)),sendJson:(e,t)=>p(e,JSON.stringify(t)),sendBinary:(e,t)=>p(e,a(t),{binary:!0}),wait:(e,t)=>new Promise(e=>setTimeout(e,t)),exec:async(e,t)=>t(e),expectMessage:async(e,t,n,o)=>{const s={...e.defaultExpectOptions,...o},c=await Promise.race([e.messages.pop(s.timeout).catch(e=>{throw new Error(`Expected message ${l(n)}, but got ${e}`)}),e.closed.then(({code:e,data:t})=>{throw new Error(`Expected message ${l(n)}, but connection closed: ${e} "${t}"`)})]).then(t);if(void 0!==n)if("function"==typeof n){if(!1===n(c))throw new Error(`Expected message ${l(n)}, got ${l(c)}`)}else if(!r.isDeepStrictEqual(c,n))throw new Error(`Expected message ${l(n)}, got ${l(c)}`)},expectText:(e,t,n)=>{let r;return t instanceof RegExp?(r=e=>t.test(e),r.expectedMessage="matching "+t):r=t,h.expectMessage(e,u,r,n)},expectJson:(e,t,n)=>h.expectMessage(e,f,t,n),expectBinary:(e,t,n)=>{let r;if("function"==typeof t)r=t;else if(t){const e=a(t);r=t=>{return n=t,r=e,Buffer.from(n.buffer,n.byteOffset,n.byteLength).equals(r);var n,r},r.expectedMessage=l(e)}return h.expectMessage(e,d,r,n)},close:(e,t,n)=>e.close(t,n),expectClosed:async(e,t=null,n=null)=>{const{code:r,data:o}=await e.closed;if(null!==t&&r!==t)throw new Error(`Expected close code ${t}, got ${r} "${o}"`);if(null!==n&&String(o)!==n)throw new Error(`Expected close message "${n}", got ${r} "${o}"`)},expectUpgrade:async(e,t)=>{const n=await e.upgrade;if(!1===t(n))throw new Error(`Expected Upgrade matching assertion, got: status ${n.statusCode} headers ${JSON.stringify(n.headers)}`)}};function g(e){throw e.close(),new Error("Expected connection failure, but succeeded")}function w(e){return e.readyState===s.CONNECTING||e.readyState===s.OPEN}function y(e,t){const n=t.toLowerCase();return Object.keys(e).find(e=>e.toLowerCase()===n)||n}const m=()=>{throw new Error("WebSocket has already been established; cannot change configuration")};function x(e,t,n,r){"object"!=typeof n||null===n||Array.isArray(n)||(r=n,n=[]);const o={...r,headers:{...(r||{}).headers}};let c=Promise.resolve().then(()=>new Promise((r,c)=>{const a=new s(t,n,o);e.clientSockets.add(a);const u=a.close.bind(a);a.close=(...t)=>{u(...t),e.clientSockets.delete(a)},Object.assign(a,e),a.messages=new i;const f=new i,d=new i,p=new i;a.closed=d.pop(),a.firstError=f.pop().then(e=>{throw e}),a.upgrade=p.pop(),a.on("message",(e,t)=>{void 0!==t?a.messages.push({data:e,isBinary:t}):"string"==typeof e?a.messages.push({data:Buffer.from(e,"utf8"),isBinary:!1}):a.messages.push({data:e,isBinary:!0})}),a.on("error",c),a.on("close",(t,n)=>{e.clientSockets.delete(a),d.push({code:t,data:n})}),a.on("open",()=>{a.removeListener("error",c),a.on("error",e=>f.push(e)),r(a)}),a.on("upgrade",e=>{p.push(e)})}));const a={set:(e,t)=>"object"==typeof e?(Object.entries(e).forEach(([e,t])=>a.set(e,t)),c):(o.headers[y(o.headers,e)]=t,c),unset:e=>(delete o.headers[y(o.headers,e)],c)};function u(e){delete e.expectConnectionError,Object.keys(a).forEach(t=>{e[t]=m})}Object.assign(c,a);const f={};function d(e){return Object.assign(e,f)}const p=e=>(...t)=>(c=c.then(n=>Promise.race([e(n,...t),n.firstError]).catch(function(e){return t=>{throw w(e)&&e.close(),t}}(n)).then(()=>n)),u(c),d(c));return Object.keys(h).forEach(e=>{f[e]=p(h[e])}),c.expectConnectionError=(e=null)=>(c=c.then(g,t=>function(e,t){if(!t)return;let n=t;"number"==typeof t&&(n="Unexpected server response: "+t);const r=e.message;if(r!==n)throw new Error(`Expected connection failure with message "${n}", got "${r}"`)}(t,e)),u(c),c),d(c)}const b=new WeakMap;function E(e,t){let n=b.get(e);if(n)return void(n.shutdownDelay=Math.max(n.shutdownDelay,t));n={shutdownDelay:t},b.set(e,n);const r=new Set;e.on("connection",e=>{r.add(e),e.on("close",()=>r.delete(e))});const o=e.close.bind(e);e.close=t=>{e.address()?(!function(e,t){if(t<=0)return void[...e].forEach(e=>e.end());const n=Date.now()+t;[...e].forEach(async t=>{for(;Date.now()<n&&e.has(t);)await new Promise(e=>setTimeout(e,20));e.has(t)&&t.end()})}(r,n.shutdownDelay),n.shutdownDelay=0,o(t)):t&&t()}}const $=/^http/;const v=function e(){const t=new Set,n=(e,{shutdownDelay:n=0,defaultExpectOptions:r={}}={})=>{const s=function(e){if("string"==typeof e)return e;const t=e.address();if(!t)throw new Error("Server must be listening:\nbeforeEach((done) => server.listen(0, done));\nafterEach((done) => server.close(done));\n\nsupertest's request(app) syntax is not supported (find out more: https://github.com/davidje13/superwstest#why-isnt-requestapp-supported)");const n=e instanceof c.Server?"https":"http";let r;return r="object"==typeof t?"ipv6"===t.family.toLowerCase()?`[${t.address}]`:t.address:t,`${n}://${r}:${t.port}`}(e);"string"!=typeof e&&E(e,n);const i={defaultExpectOptions:r,clientSockets:t},a=o(s);return a.ws=(e,...t)=>x(i,s.replace($,"ws")+e,...t),a};return n.closeAll=()=>{const e=[...t].filter(w);return t.clear(),e.forEach(e=>e.close()),e.length},n.scoped=()=>e(),n}();v.default=v;var O=v}]).default}));
//# sourceMappingURL=index.js.map